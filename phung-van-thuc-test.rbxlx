<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="22">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<float name="AirTurbulenceIntensity">0</float>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AuthorityMode">1</token>
			<token name="AvatarUnificationMode">0</token>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBX6053A67C6F774052B5B715C5AA2A6F96</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<bool name="FallHeightEnabled">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LuauTypeCheckMode">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<token name="ModelStreamingBehavior">0</token>
			<token name="MoverConstraintRootBehavior">0</token>
			<token name="PathfindingUseImprovedSearch">0</token>
			<token name="PhysicsImprovedSleep">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<token name="RejectCharacterDeletions">0</token>
			<token name="RenderingCacheOptimizations">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SandboxedInstanceMode">0</token>
			<token name="SignalBehavior2">0</token>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<bool name="TerrainWeldsFixed">true</bool>
			<token name="TouchEventsUseCollisionGroups">0</token>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<token name="UseNewLuauTypeSolver">0</token>
			<token name="LevelOfDetail">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingMode">0</token>
			<bool name="NeedsPivotMigration">false</bool>
			<Ref name="PrimaryPart">null</Ref>
			<float name="ScaleFactor">1</float>
			<SharedString name="SlimHash">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Workspace</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000002</UniqueId>
		</Properties>
		<Item class="Camera" referent="RBX6053A67C6F774052B5B715C5AA2A6F96">
			<Properties>
				<CoordinateFrame name="CFrame">
					<X>28.0811119</X>
					<Y>37.0432701</Y>
					<Z>-11.275423</Z>
					<R00>0.90777719</R00>
					<R01>-0.0522827916</R01>
					<R02>0.416181624</R02>
					<R10>3.72528985e-09</R10>
					<R11>0.992201447</R11>
					<R12>0.124645248</R12>
					<R20>-0.419452727</R20>
					<R21>-0.113150112</R21>
					<R22>0.900697827</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>27.2487488</X>
					<Y>36.7939796</Y>
					<Z>-13.0768185</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<bool name="VRTiltAndRollEnabled">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000036d</UniqueId>
			</Properties>
		</Item>
		<Item class="Part" referent="23">
			<Properties>
				<token name="shape">1</token>
				<token name="formFactorRaw">1</token>
				<bool name="Anchored">true</bool>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284636770</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>512</X>
					<Y>20</Y>
					<Z>512</Z>
				</Vector3>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Baseplate</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a4</UniqueId>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX1480864214D44446B6AB5FED926038D7">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Decoration">false</bool>
				<float name="GrassLength">0.699999988</float>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<bool name="Anchored">true</bool>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Terrain</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a5</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="TimerService" referent="RBX0A781E1C676F421494C86CFE224D7071">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TimerService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000324</UniqueId>
		</Properties>
	</Item>
	<Item class="SoundService" referent="11">
		<Properties>
			<bool name="AcousticSimulationEnabled">false</bool>
			<token name="AmbientReverb">0</token>
			<token name="AudioApiByDefault">0</token>
			<token name="AudioPlayerVolumeFix">0</token>
			<token name="CharacterSoundsUseNewApi">0</token>
			<token name="DefaultListenerLocation">0</token>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<bool name="IsNewExpForAudioApiByDefault">false</bool>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<token name="VolumetricAudio">1</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">SoundService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000325</UniqueId>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBXB602F583C3D14C26B1CDE0F105C8675B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000331</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBXE4D1451BBC3A45558F63618DBFCF612E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000332</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX59563D4F17E04CF083E75D70472B9495">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000333</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXE0012E304CD5451CA4895681C1C5C595">
		<Properties>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="IsAutoMigrated">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000339</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX7F360BC0EACD4C329CD748DF996E292D">
		<Properties>
			<bool name="BanningEnabled">true</bool>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<bool name="UseStrafingAnimations">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Players</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000033b</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX0BA2E377AE794A0FBD4E22CA393BE407">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000033e</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBXE5283E9E700A4CE5852C33038FDE6AF2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000340</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX64866581FF1947A5BDFEFFD4042F4131">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">MaterialService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000341</UniqueId>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX7FF6B558E30F411D94E05BD21573DD00">
		<Properties>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="HasSeenDeprecationDialog">false</bool>
			<bool name="IsLegacyChatDisabled">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000342</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX6B8B8C66C66046B2AEE9CBA052993D7F">
			<Properties>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<token name="HorizontalAlignment">1</token>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a7</UniqueId>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBX424DBFE8713541A0B6D88D843FE453FA">
			<Properties>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<token name="KeyboardKeyCode">47</token>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ChatInputBarConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a8</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBXE426D1DC62694E32BE0BB763CF4CAAE9">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<float name="VerticalStudsOffset">0</float>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a9</UniqueId>
			</Properties>
		</Item>
		<Item class="ChannelTabsConfiguration" referent="RBX3A9D22BE35274D99ADE3649B7F9A04CE">
			<Properties>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0</double>
				<bool name="Enabled">false</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/BuilderSans.json</url></Family>
					<Weight>700</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/BuilderSans-Bold.otf</url></CachedFaceId>
				</Font>
				<Color3 name="HoverBackgroundColor3">
					<R>0.490196079</R>
					<G>0.490196079</G>
					<B>0.490196079</B>
				</Color3>
				<Color3 name="SelectedTabTextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<Color3 name="TextColor3">
					<R>0.686274529</R>
					<G>0.686274529</G>
					<B>0.686274529</B>
				</Color3>
				<int64 name="TextSize">18</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">1</double>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ChannelTabsConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003aa</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBXDA7B9D5B83104A0DA3711A52A862C4AF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000344</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXE98A3DCA1DD54746B1933F3143D3FBB5">
		<Properties>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int name="TextElongationFactor">0</int>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000345</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX87F9D6E46D4A414EB208B1256452D927">
		<Properties>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000349</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="12">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_SerializedRollout">0</token>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<bool name="ClassicDeath">true</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<float name="NameDisplayDistance">100</float>
			<bool name="RagdollDeath">true</bool>
			<bool name="UserEmotesEnabled">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPlayer</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000034b</UniqueId>
		</Properties>
		<Item class="StarterPlayerScripts" referent="13">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000039b</UniqueId>
			</Properties>
			<Item class="LocalScript" referent="14">
				<Properties>
					<ProtectedString name="Source"><![CDATA[-- Main client initialization
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ShardEffects = require(script.ShardEffects)
local ShardCollector = require(script.ShardCollector)
local PuzzleController = require(script.PuzzleController)
local HUD = require(script.HUD)
local CompletionModal = require(script.CompletionModal)
local CountdownPopup = require(script.CountdownPopup)
local SoundManager = require(script.SoundManager)
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

-- Initialize modules
local shard_effects = ShardEffects.new()
local shard_collector = ShardCollector.new()
local puzzle_controller = PuzzleController.new()
local hud = HUD.new()
local completion_modal = CompletionModal.new()
local countdown_popup = CountdownPopup.new()
local sound_manager = SoundManager.new()

-- Export sound_manager globally for easy access (optional)
_G.SoundManager = sound_manager

-- Wait for player and services to fully load
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Wait for PlayerGui to be ready (helps avoid CoreGui errors)
if player then
	player:WaitForChild("PlayerGui", 10)
	-- Additional wait to ensure all core scripts are loaded
	task.wait(0.5)
end

-- Start shard effects
shard_effects:start_effects()

-- Initialize shard collector
shard_collector:initialize()

-- Initialize puzzle controller
puzzle_controller:initialize()

-- Create HUD (with error handling)
local success, err = pcall(function()
	hud:create()
end)
if not success then
	warn("[init.client] Error creating HUD:", err)
end

-- Create completion modal (with error handling)
success, err = pcall(function()
	completion_modal:create()
end)
if not success then
	warn("[init.client] Error creating completion modal:", err)
end

-- Create countdown popup (with error handling)
success, err = pcall(function()
	countdown_popup:create()
end)
if not success then
	warn("[init.client] Error creating countdown popup:", err)
end

-- Listen for puzzle solved to show countdown
RemoteEvents.PuzzleSolved.OnClientEvent:Connect(function(completion_time)
	-- Show countdown popup
	countdown_popup:show(function()
		-- After countdown, request gate to open
		RemoteEvents.OpenGateNow:FireServer()
		-- Play gate opening sound
		if sound_manager then
			sound_manager:play_sound_2d(74860753060159, {Volume = 0.7})
		end
	end)
end)

-- Listen for game reset to hide countdown
RemoteEvents.GameReset.OnClientEvent:Connect(function()
	countdown_popup:hide()
end)

print("Client initialized!")
]]></ProtectedString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{A952855C-F32B-49A3-AE3F-6339F032C8CA}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Client</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000039c</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="15">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- CompletionModal: Shows completion screen with time and reset option
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local SoundManager = require(script.Parent.SoundManager)

local CompletionModal = {}
CompletionModal.__index = CompletionModal

local player = Players.LocalPlayer
local player_gui = nil
local modal_gui = nil
local is_visible = false
local sound_manager = nil -- SoundManager instance

function CompletionModal.new()
	local self = setmetatable({}, CompletionModal)
	return self
end

function CompletionModal:create()
	-- Get SoundManager instance
	sound_manager = _G.SoundManager or SoundManager.new()
	
	player_gui = player:WaitForChild("PlayerGui")
	
	-- Create ScreenGui for modal
	modal_gui = Instance.new("ScreenGui")
	modal_gui.Name = "CompletionModal"
	modal_gui.ResetOnSpawn = false
	modal_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	modal_gui.DisplayOrder = 10
	modal_gui.Parent = player_gui
	
	-- Create background overlay
	local overlay = Instance.new("Frame")
	overlay.Name = "Overlay"
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	overlay.BackgroundTransparency = 0.5
	overlay.BorderSizePixel = 0
	overlay.Parent = modal_gui
	
	-- Create modal frame
	local modal_frame = Instance.new("Frame")
	modal_frame.Name = "ModalFrame"
	modal_frame.Size = UDim2.new(0.9, 0, 0.9, 0) -- 90% height of screen
	modal_frame.Position = UDim2.new(0.5, 0, 0.5, 0) -- center of screen
	modal_frame.AnchorPoint = Vector2.new(0.5, 0.5) -- center of screen
	modal_frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	modal_frame.BorderSizePixel = 0
	modal_frame.Parent = modal_gui

	local size_constraint = Instance.new("UISizeConstraint")
	size_constraint.MaxSize = Vector2.new(600, 400)  -- Maximum: 600x400 pixels
	size_constraint.Parent = modal_frame
	
	-- Add corner radius
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 15)
	corner.Parent = modal_frame
	
	-- Add title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -40, 0, 60)
	title.Position = UDim2.new(0.5, 0, 0.15, 0)
	title.AnchorPoint = Vector2.new(0.5, 0.5)
	title.BackgroundTransparency = 1
	title.Text = "Gate Opened!"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.TextSize = 36
	title.Font = Enum.Font.GothamBold
	title.Parent = modal_frame
	
	-- Add completion time label
	local time_label = Instance.new("TextLabel")
	time_label.Name = "TimeLabel"
	time_label.Size = UDim2.new(1, -40, 0, 50)
	time_label.Position = UDim2.new(0, 20, 0.25, 0)
	time_label.BackgroundTransparency = 1
	time_label.Text = "Completion Time: 00:00"
	time_label.TextColor3 = Color3.fromRGB(200, 200, 200)
	time_label.TextSize = 24
	time_label.Font = Enum.Font.Gotham
	time_label.Parent = modal_frame
	
	-- Create button container
	local button_container = Instance.new("Frame")
	button_container.Name = "ButtonContainer"
	local horizontalPadding = 20  
	local bottomPadding = 20
	button_container.AnchorPoint = Vector2.new(0.5, 1)
	button_container.Position = UDim2.new(0.5, 0, 1, -bottomPadding)
	button_container.Size = UDim2.new(1, -2 * horizontalPadding, 0.25, 0)
	button_container.BackgroundTransparency = 1
	button_container.Parent = modal_frame
	
	-- Create Reset button
	local reset_button = Instance.new("TextButton")
	reset_button.Name = "ResetButton"
	reset_button.Size = UDim2.new(0.45, 0, 1, 0)
	reset_button.Position = UDim2.new(0, 0, 0, 0)
	reset_button.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	reset_button.Text = "Reset Run"
	reset_button.TextColor3 = Color3.fromRGB(255, 255, 255)
	reset_button.TextSize = 20
	reset_button.Font = Enum.Font.GothamBold
	reset_button.Parent = button_container
	
	local reset_corner = Instance.new("UICorner")
	reset_corner.CornerRadius = UDim.new(0, 8)
	reset_corner.Parent = reset_button
	
	-- Create Close button
	local close_button = Instance.new("TextButton")
	close_button.Name = "CloseButton"
	close_button.Size = UDim2.new(0.45, 0, 1, 0)
	close_button.Position = UDim2.new(0.55, 0, 0, 0)
	close_button.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	close_button.Text = "Close"
	close_button.TextColor3 = Color3.fromRGB(255, 255, 255)
	close_button.TextSize = 20
	close_button.Font = Enum.Font.GothamBold
	close_button.Parent = button_container
	
	local close_corner = Instance.new("UICorner")
	close_corner.CornerRadius = UDim.new(0, 8)
	close_corner.Parent = close_button
	
	-- Button events
	reset_button.MouseButton1Click:Connect(function()
		-- Play button sound
		if sound_manager then
			sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
		end
		RemoteEvents.ResetGame:FireServer()
		self:hide()
	end)
	
	close_button.MouseButton1Click:Connect(function()
		-- Play button sound
		if sound_manager then
			sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
		end
		self:hide()
	end)
	
	-- Make responsive
	local ui_scale = Instance.new("UIScale")
	ui_scale.Parent = modal_gui
	
	-- Initially hidden
	modal_gui.Enabled = false
	
	-- Listen for completion event (after gate opens)
	RemoteEvents.GameComplete.OnClientEvent:Connect(function(completion_time)
		task.wait(2)
		self:show(completion_time)
	end)
	
	-- Listen for game reset event (when another player resets the game)
	RemoteEvents.GameReset.OnClientEvent:Connect(function()
		-- If modal is visible, just hide it (game was already reset by another player)
		if is_visible then
			self:hide()
		end
	end)
end

function CompletionModal:show(completion_time)
	if not modal_gui then
		return
	end
	
	is_visible = true
	modal_gui.Enabled = true
	
	-- Play completion sound
	if sound_manager then
		sound_manager:play_sound_2d(122635127122416, {Volume = 0.7})
	end
	
	-- Update time label
	local time_label = modal_gui.ModalFrame:FindFirstChild("TimeLabel")
	if time_label then
		local minutes = math.floor(completion_time / 60)
		local seconds = math.floor(completion_time % 60)
		time_label.Text = string.format("Completion Time: %02d:%02d", minutes, seconds)
	end
end

function CompletionModal:hide()
	if not modal_gui then
		return
	end
	
	is_visible = false
	modal_gui.Enabled = false
end

return CompletionModal

]]></ProtectedString>
						<string name="ScriptGuid">{EF515F67-D328-461A-BE7A-FF05127D470D}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">CompletionModal</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000039d</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="16">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- CountdownPopup: Shows countdown popup before gate opens
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local CountdownPopup = {}
CountdownPopup.__index = CountdownPopup

local player = Players.LocalPlayer
local player_gui = nil
local popup_gui = nil
local is_visible = false
local countdown_connection = nil

function CountdownPopup.new()
	local self = setmetatable({}, CountdownPopup)
	return self
end

function CountdownPopup:create()
	player_gui = player:WaitForChild("PlayerGui")
	
	-- Create ScreenGui for popup
	popup_gui = Instance.new("ScreenGui")
	popup_gui.Name = "CountdownPopup"
	popup_gui.ResetOnSpawn = false
	popup_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	popup_gui.DisplayOrder = 8
	popup_gui.Parent = player_gui
	
	-- Create popup frame
	local popup_frame = Instance.new("Frame")
	popup_frame.Name = "PopupFrame"
	popup_frame.Size = UDim2.new(0, 300, 0, 120)
	popup_frame.Position = UDim2.new(0.5, 0, 0.3, 0)
	popup_frame.AnchorPoint = Vector2.new(0.5, 0.5)
	popup_frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	popup_frame.BackgroundTransparency = 0.1
	popup_frame.BorderSizePixel = 0
	popup_frame.Parent = popup_gui
	
	-- Add corner radius
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 15)
	corner.Parent = popup_frame
	
	-- Add stroke
	local stroke = Instance.new("UIStroke")
	stroke.Color = Color3.fromRGB(255, 200, 0)
	stroke.Thickness = 3
	stroke.Parent = popup_frame
	
	-- Create text label
	local text_label = Instance.new("TextLabel")
	text_label.Name = "TextLabel"
	text_label.Size = UDim2.new(1, -40, 1, -40)
	text_label.Position = UDim2.new(0, 20, 0, 20)
	text_label.BackgroundTransparency = 1
	text_label.Text = "Gate opened in 3 seconds."
	text_label.TextColor3 = Color3.fromRGB(255, 255, 255)
	text_label.TextSize = 24
	text_label.Font = Enum.Font.GothamBold
	text_label.TextWrapped = true
	text_label.Parent = popup_frame
	
	-- Add text size constraint
	local text_constraint = Instance.new("UITextSizeConstraint")
	text_constraint.MaxTextSize = 28
	text_constraint.MinTextSize = 18
	text_constraint.Parent = text_label
	
	-- Make responsive
	local ui_scale = Instance.new("UIScale")
	ui_scale.Parent = popup_gui
	
	-- Initially hidden
	popup_gui.Enabled = false
end

function CountdownPopup:show(callback)
	if not popup_gui then
		return
	end
	
	if is_visible then
		return
	end
	
	is_visible = true
	popup_gui.Enabled = true
	
	local text_label = popup_gui.PopupFrame:FindFirstChild("TextLabel")
	if not text_label then
		return
	end
	
	-- Animate in
	local popup_frame = popup_gui.PopupFrame
	popup_frame.Size = UDim2.new(0, 0, 0, 0)
	local tween_in = TweenService:Create(
		popup_frame,
		TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{Size = UDim2.new(0, 300, 0, 120)}
	)
	tween_in:Play()
	
	-- Start countdown from 3 to 0
	local count = 3
	text_label.Text = string.format("Gate opened in %d seconds.", count)
	
	-- Countdown loop
	countdown_connection = game:GetService("RunService").Heartbeat:Connect(function()
		-- This will be replaced by a proper countdown timer
	end)
	
	-- Use spawn for countdown
	spawn(function()
		for i = 3, 0, -1 do
			if not is_visible then
				break
			end
			
			text_label.Text = string.format("Gate opened in %d seconds.", i)
			
			-- Pulse animation
			local pulse_tween = TweenService:Create(
				text_label,
				TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{TextSize = 28}
			)
			pulse_tween:Play()
			pulse_tween.Completed:Connect(function()
				local reset_tween = TweenService:Create(
					text_label,
					TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{TextSize = 24}
				)
				reset_tween:Play()
			end)
			
			if i > 0 then
				task.wait(1)
			end
		end
		
		-- Countdown finished
		if is_visible then
			text_label.Text = "Gate opened!"
			
			-- Animate out
			local tween_out = TweenService:Create(
				popup_frame,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Size = UDim2.new(0, 0, 0, 0)}
			)
			tween_out:Play()
			tween_out.Completed:Connect(function()
				self:hide()
				if callback then
					callback()
				end
			end)
		end
	end)
end

function CountdownPopup:hide()
	if not popup_gui then
		return
	end
	
	is_visible = false
	popup_gui.Enabled = false
	
	if countdown_connection then
		countdown_connection:Disconnect()
		countdown_connection = nil
	end
end

return CountdownPopup

]]></ProtectedString>
						<string name="ScriptGuid">{0C3E342A-6139-4BB6-83CF-C3244B073D1B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">CountdownPopup</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000039e</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="17">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- HUD: Manages game HUD (shard counter and timer)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local Config = require(ReplicatedStorage.Shared.Config)

local HUD = {}
HUD.__index = HUD

local player = Players.LocalPlayer
local player_gui = nil
local screen_gui = nil
local shard_label = nil
local timer_label = nil
local timer_start_time = 0
local timer_running = false

function HUD.new()
	local self = setmetatable({}, HUD)
	return self
end

function HUD:create()
	-- Create ScreenGui
	player_gui = player:WaitForChild("PlayerGui")
	
	screen_gui = Instance.new("ScreenGui")
	screen_gui.Name = "GameHUD"
	screen_gui.ResetOnSpawn = false
	screen_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screen_gui.Parent = player_gui
	
	-- Create main frame (top right + responsive)
	local main_frame = Instance.new("Frame")
	main_frame.Name = "MainFrame"
	main_frame.Size = UDim2.new(0.15, 0, 0.1, 0)      -- 15% width, 10% height: auto resize
	main_frame.AnchorPoint = Vector2.new(0, 0)         -- Anchor at left top
	main_frame.Position = UDim2.new(0, 10, 0, 10)     -- X=10px, Y=10px
	main_frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	main_frame.BackgroundTransparency = 0.3
	main_frame.BorderSizePixel = 0

	local size_constraint = Instance.new("UISizeConstraint")
	size_constraint.MinSize = Vector2.new(75, 25)
	size_constraint.Parent = main_frame

	-- Add UICorner to main frame
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = main_frame

	-- Add UIPadding to main frame
	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0.1, 0)      -- 10% padding top
	padding.PaddingBottom = UDim.new(0.1, 0)   -- 10% padding bottom
	padding.PaddingLeft = UDim.new(0.05, 0)    -- 5% padding left
	padding.PaddingRight = UDim.new(0.05, 0)   -- 5% padding right
	padding.Parent = main_frame

	-- Add main frame to screen gui
	main_frame.Parent = screen_gui

	-- Create shard counter label
	shard_label = Instance.new("TextLabel")
	shard_label.Name = "ShardLabel"
	shard_label.Size = UDim2.new(1, 0, 0.45, 0)        -- 100% width, 45% height (Scale only)
	shard_label.Position = UDim2.new(0, 0, 0, 0)       -- Top position (Scale only)
	shard_label.BackgroundTransparency = 1
	shard_label.Text = "Shards: 0/" .. Config.SHARD_COUNT
	shard_label.TextColor3 = Color3.fromRGB(255, 255, 255)
	shard_label.TextScaled = true                      -- Auto scale text
	shard_label.TextXAlignment = Enum.TextXAlignment.Left
	shard_label.Font = Enum.Font.GothamBold
	shard_label.Parent = main_frame
	
	-- Add UITextSizeConstraint to shard label
	local shardTextConstraint = Instance.new("UITextSizeConstraint")
	shardTextConstraint.MinTextSize = 10              -- Minimum 10px
	shardTextConstraint.MaxTextSize = 28              -- Maximum 28px
	shardTextConstraint.Parent = shard_label

	-- Create timer label
	timer_label = Instance.new("TextLabel")
	timer_label.Name = "TimerLabel"
	timer_label.Size = UDim2.new(1, 0, 0.45, 0)       -- 100% width, 45% height (Scale only)
	timer_label.Position = UDim2.new(0, 0, 0.55, 0)   -- Start at 55% from top (Scale only)
	timer_label.BackgroundTransparency = 1
	timer_label.Text = "Time: 00:00"
	timer_label.TextColor3 = Color3.fromRGB(255, 255, 255)
	timer_label.TextScaled = true                     -- Auto scale text
	timer_label.TextXAlignment = Enum.TextXAlignment.Left
	timer_label.Font = Enum.Font.GothamBold
	timer_label.Parent = main_frame

	local timerTextConstraint = Instance.new("UITextSizeConstraint")
	timerTextConstraint.MinTextSize = 10
	timerTextConstraint.MaxTextSize = 28
	timerTextConstraint.Parent = timer_label
	
	-- Make responsive
	local ui_scale = Instance.new("UIScale")
	ui_scale.Parent = screen_gui
	
	-- Listen for updates
	self:setup_listeners()
end

function HUD:setup_listeners()
	-- Listen for shard state updates
	RemoteEvents.ShardStateUpdate.OnClientEvent:Connect(function(shard_states, player_count)
		self:update_shard_count(player_count)
	end)
	
	-- Listen for timer start
	RemoteEvents.TimerStart.OnClientEvent:Connect(function(start_time_value)
		if start_time_value > 0 then
			timer_start_time = start_time_value
			timer_running = true
			self:start_timer()
		else
			-- Reset timer
			timer_running = false
			timer_start_time = 0
			if timer_label then
				timer_label.Text = "Time: 00:00"
			end
		end
	end)
	
	-- Listen for all shards collected
	RemoteEvents.AllShardsCollected.OnClientEvent:Connect(function()
		self:show_all_shards_collected_message()
	end)
end

function HUD:show_all_shards_collected_message()
	-- Create notification message
	if not screen_gui then
		return
	end
	
	-- Remove existing notification if any
	local existing_notification = screen_gui:FindFirstChild("AllShardsNotification")
	if existing_notification then
		existing_notification:Destroy()
	end
	
	local notification = Instance.new("Frame")
	notification.Name = "AllShardsNotification"
	notification.Size = UDim2.new(0.9, 0, 0.1, 0)
	notification.Position = UDim2.new(0.5, 0, 0.5, 0)
	notification.AnchorPoint = Vector2.new(0.5, 0.5)
	notification.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
	notification.BackgroundTransparency = 0.2
	notification.BorderSizePixel = 0
	notification.Parent = screen_gui
	
	local size_constraint = Instance.new("UISizeConstraint")
	size_constraint.MaxSize = Vector2.new(600, 100)  -- Maximum: 600x100 pixels
	size_constraint.Parent = notification
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = notification
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -20, 1, -20)
	label.Position = UDim2.new(0, 10, 0, 10)
	label.BackgroundTransparency = 1
	label.Text = "All Shards Collected!\nGo to the puzzle at z=60 to continue!"
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextSize = 20
	label.Font = Enum.Font.GothamBold
	label.TextWrapped = true
	label.Parent = notification
	
	-- Animate in
	notification.Size = UDim2.new(0, 0, 0, 0)
	local tween_service = game:GetService("TweenService")
	local tween_info = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local goal = {Size = UDim2.new(0, 400, 0, 100)}
	local tween = tween_service:Create(notification, tween_info, goal)
	tween:Play()
	
	-- Auto-hide after 5 seconds (use spawn to avoid blocking)
	spawn(function()
		task.wait(5)
		
		-- Animate out
		local tween_out = tween_service:Create(notification, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Size = UDim2.new(0, 0, 0, 0)})
		tween_out:Play()
		tween_out.Completed:Connect(function()
			notification:Destroy()
		end)
	end)
end

function HUD:update_shard_count(count)
	if shard_label then
		shard_label.Text = "Shards: " .. (count or 0) .. "/" .. Config.SHARD_COUNT
	end
end

function HUD:start_timer()
	if not timer_running then
		return
	end
	
	-- Update timer every frame
	local connection
	connection = game:GetService("RunService").Heartbeat:Connect(function()
		if not timer_running then
			connection:Disconnect()
			return
		end
		
		local elapsed = tick() - timer_start_time
		local minutes = math.floor(elapsed / 60)
		local seconds = math.floor(elapsed % 60)
		
		if timer_label then
			timer_label.Text = string.format("Time: %02d:%02d", minutes, seconds)
		end
	end)
end

function HUD:stop_timer()
	timer_running = false
end

function HUD:get_elapsed_time()
	if timer_running and timer_start_time > 0 then
		return tick() - timer_start_time
	end
	return 0
end

return HUD

]]></ProtectedString>
						<string name="ScriptGuid">{A725C2BC-6D8D-4356-89FB-D5D30746BF8C}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">HUD</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000039f</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="18">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- PuzzleController: Handles puzzle interaction on client
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
-- GuiService removed as it's not used

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local SoundManager = require(script.Parent.SoundManager)

local PuzzleController = {}
PuzzleController.__index = PuzzleController

local puzzle_active = false
local puzzle_solved = false -- Track if puzzle is solved on client
local puzzle_gui = nil
local player = Players.LocalPlayer
local keyboard_connection = nil
local start_button_connection = nil
local proximity_connection = nil
local ring_buttons = {} -- Store ring buttons to enable/disable them
local sound_manager = nil -- SoundManager instance

function PuzzleController.new()
	local self = setmetatable({}, PuzzleController)
	return self
end

function PuzzleController:connect_start_button()
	-- Get puzzle folder
	local puzzle_folder = Workspace:FindFirstChild("Puzzle")
	if not puzzle_folder then
		return
	end
	
	-- Function to connect to start button when it's created
	local function connect_start_button_internal()
		local start_button = puzzle_folder:FindFirstChild("StartButton")
		if start_button and not start_button_connection then
			start_button.CanTouch = true

			-- Use proximity detection as backup for start button
			local RunService = game:GetService("RunService")
			
			-- Store reference to start_button for closure
			local button_ref = start_button
			
			local start_button_touched = false
			start_button_connection = start_button.Touched:Connect(function(hit)
				if start_button_touched or puzzle_active then
					return
				end
				
				local character = hit.Parent
				
				-- Check if hit part belongs to player's character
				if character == player.Character or (player.Character and hit:IsDescendantOf(player.Character)) then
					start_button_touched = true
					-- Play button sound
					if sound_manager then
						sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
					end
					RemoteEvents.PuzzleInteract:FireServer("start", 0)
				end
			end)
			
			-- Proximity detection for start button (runs continuously)
			local start_button_activated = false
			local last_log_time = 0
			proximity_connection = RunService.Heartbeat:Connect(function()
				if puzzle_active or start_button_activated or not button_ref.Parent then
					if proximity_connection then
						proximity_connection:Disconnect()
						proximity_connection = nil
					end
					return
				end
				
				if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					local distance = (button_ref.Position - player.Character.HumanoidRootPart.Position).Magnitude
					local current_time = tick()
					
					-- Log distance every 2 seconds
					if current_time - last_log_time > 2 then
						last_log_time = current_time
					end
					
					if distance <= 10 then -- Increased threshold to 10 units
						start_button_activated = true
						if proximity_connection then
							proximity_connection:Disconnect()
							proximity_connection = nil
						end
						-- Play button sound
						if sound_manager then
							sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
						end
						RemoteEvents.PuzzleInteract:FireServer("start", 0)
					end
				end
			end)
		end
	end
	
	-- Try to connect immediately (in case button already exists)
	connect_start_button_internal()
	
	-- Listen for start button being added to puzzle folder (only if not already listening)
	-- Note: This connection persists, so we don't need to recreate it
	if not puzzle_folder:GetAttribute("StartButtonListenerAdded") then
		puzzle_folder:SetAttribute("StartButtonListenerAdded", true)
		puzzle_folder.ChildAdded:Connect(function(child)
			if child.Name == "StartButton" then
				connect_start_button_internal()
			end
		end)
	end
end

function PuzzleController:initialize()
	-- Get SoundManager instance
	sound_manager = _G.SoundManager or SoundManager.new()
	
	-- Wait for puzzle to be created
	local puzzle_folder = Workspace:WaitForChild("Puzzle", 10)
	if not puzzle_folder then
		warn("[PuzzleController] Puzzle folder not found after 10 seconds!")
		-- Try to find it again
		puzzle_folder = Workspace:FindFirstChild("Puzzle")
		if not puzzle_folder then
			warn("[PuzzleController] Puzzle folder still not found!")
			return
		end
	end
	
	-- Connect to start button
	self:connect_start_button()
	
	-- Touched event removed - rings can only be rotated via UI buttons or keyboard
	-- No need to connect Touched event or ClickDetector
	
	-- Listen for puzzle state updates
	RemoteEvents.PuzzleStateUpdate.OnClientEvent:Connect(function(active, angles)
		local old_active = puzzle_active
		puzzle_active = active
		
		-- Check if puzzle was solved (active becomes false after solving)
		if old_active and not active then
			puzzle_solved = true
		end
		
		if active and not old_active then
			-- Reset solved flag when puzzle becomes active again
			puzzle_solved = false
			-- Create puzzle control GUI
			self:create_puzzle_gui()
			-- Setup keyboard controls
			self:setup_keyboard_controls()
			-- Enable buttons
			self:enable_ring_buttons()
		elseif not active and old_active then
			-- Disable buttons when puzzle is not active or solved
			self:disable_ring_buttons()
			-- Hide puzzle GUI when puzzle is not active
			if puzzle_gui then
				puzzle_gui.Enabled = false
			end
			-- Disconnect keyboard controls
			if keyboard_connection then
				keyboard_connection:Disconnect()
				keyboard_connection = nil
			end
		end
	end)
	
	-- Periodic check to remind player
	spawn(function()
		task.wait(5)
		if not puzzle_active then
		end
	end)
	
	-- Listen for game reset event
	RemoteEvents.GameReset.OnClientEvent:Connect(function()
		-- Reset puzzle state when game is reset
		puzzle_active = false
		puzzle_solved = false
		
		-- Disable buttons
		self:disable_ring_buttons()
		
		-- Hide puzzle GUI
		if puzzle_gui then
			puzzle_gui.Enabled = false
		end
		
		-- Disconnect keyboard controls
		if keyboard_connection then
			keyboard_connection:Disconnect()
			keyboard_connection = nil
		end
		
		-- Reset start button connection to allow reconnection
		if start_button_connection then
			start_button_connection:Disconnect()
			start_button_connection = nil
		end
		if proximity_connection then
			proximity_connection:Disconnect()
			proximity_connection = nil
		end
		
		-- Reconnect to start button after a delay (when puzzle elements are recreated)
		spawn(function()
			task.wait(0.5)
			-- Reconnect using the same logic
			self:connect_start_button()
		end)
	end)
end

function PuzzleController:create_puzzle_gui()
	-- Remove existing GUI if any
	if puzzle_gui then
		puzzle_gui:Destroy()
	end
	
	local player_gui = player:WaitForChild("PlayerGui")
	
	puzzle_gui = Instance.new("ScreenGui")
	puzzle_gui.Name = "PuzzleControls"
	puzzle_gui.ResetOnSpawn = false
	puzzle_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	puzzle_gui.DisplayOrder = 5
	puzzle_gui.Parent = player_gui
	
	-- Main frame
	local main_frame = Instance.new("Frame")
	main_frame.Name = "MainFrame"
	main_frame.Size = UDim2.new(0, 275, 0, 200)
	main_frame.Position = UDim2.new(1, -295, 0.5, -100)
	main_frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	main_frame.BackgroundTransparency = 0.2
	main_frame.BorderSizePixel = 0
	main_frame.Parent = puzzle_gui
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = main_frame
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -20, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "Puzzle Controls"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.TextSize = 20
	title.Font = Enum.Font.GothamBold
	title.Parent = main_frame
	
	-- Instructions
	local instructions = Instance.new("TextLabel")
	instructions.Name = "Instructions"
	instructions.Size = UDim2.new(1, -20, 0, 40)
	instructions.Position = UDim2.new(0, 10, 0, 40)
	instructions.BackgroundTransparency = 1
	instructions.Text = "Press 1/2/3 or click buttons to rotate rings"
	instructions.TextColor3 = Color3.fromRGB(200, 200, 200)
	instructions.TextSize = 14
	instructions.TextWrapped = true
	instructions.Font = Enum.Font.Gotham
	instructions.Parent = main_frame
	
	-- Button container
	local button_container = Instance.new("Frame")
	button_container.Name = "ButtonContainer"
	button_container.Size = UDim2.new(1, -20, 0, 100)
	button_container.Position = UDim2.new(0, 10, 0, 90)
	button_container.BackgroundTransparency = 1
	button_container.Parent = main_frame
	
	-- Create buttons for each ring
	for i = 1, 3 do
		local button = Instance.new("TextButton")
		button.Name = "Ring" .. i .. "Button"
		button.Size = UDim2.new(0.3, -5, 1, 0)
		button.Position = UDim2.new((i - 1) * 0.33, 0, 0, 0)
		button.BackgroundColor3 = Color3.fromRGB(255, 150, 0)
		button.Text = "Ring " .. i .. "\n(Key " .. i .. ")"
		button.TextColor3 = Color3.fromRGB(255, 255, 255)
		button.TextSize = 16
		button.Font = Enum.Font.GothamBold
		button.Parent = button_container
		
		local button_corner = Instance.new("UICorner")
		button_corner.CornerRadius = UDim.new(0, 8)
		button_corner.Parent = button
		
		-- Store button reference
		ring_buttons[i] = button
		
		-- Button click event
		button.MouseButton1Click:Connect(function()
			if puzzle_active and not puzzle_solved then
				-- Play button sound
				if sound_manager then
					sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
				end
				RemoteEvents.PuzzleInteract:FireServer("rotate", i)
			end
		end)
		
		-- Button hover effect
		button.MouseEnter:Connect(function()
			button.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
		end)
		button.MouseLeave:Connect(function()
			button.BackgroundColor3 = Color3.fromRGB(255, 150, 0)
		end)
	end
	
	-- Make responsive
	local ui_scale = Instance.new("UIScale")
	ui_scale.Parent = puzzle_gui
end

function PuzzleController:setup_keyboard_controls()
	-- Disconnect existing connection if any
	if keyboard_connection then
		keyboard_connection:Disconnect()
		keyboard_connection = nil
	end
	
	-- Keyboard input for rotating rings
	keyboard_connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then
			return
		end
		
		if not puzzle_active or puzzle_solved then
			return
		end
		
		-- Check for number keys 1, 2, 3
		if input.KeyCode == Enum.KeyCode.One then
			-- Play button sound
			if sound_manager then
				sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
			end
			RemoteEvents.PuzzleInteract:FireServer("rotate", 1)
		elseif input.KeyCode == Enum.KeyCode.Two then
			-- Play button sound
			if sound_manager then
				sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
			end
			RemoteEvents.PuzzleInteract:FireServer("rotate", 2)
		elseif input.KeyCode == Enum.KeyCode.Three then
			-- Play button sound
			if sound_manager then
				sound_manager:play_sound_2d(123872698765939, {Volume = 0.5})
			end
			RemoteEvents.PuzzleInteract:FireServer("rotate", 3)
		end
	end)
end

function PuzzleController:disable_ring_buttons()
	-- Disable all ring buttons
	for i = 1, 3 do
		if ring_buttons[i] then
			ring_buttons[i].Active = false
			ring_buttons[i].BackgroundColor3 = Color3.fromRGB(100, 100, 100) -- Gray out
		end
	end
end

function PuzzleController:enable_ring_buttons()
	-- Enable all ring buttons
	for i = 1, 3 do
		if ring_buttons[i] then
			ring_buttons[i].Active = true
			ring_buttons[i].BackgroundColor3 = Color3.fromRGB(255, 150, 0) -- Original color
		end
	end
end

return PuzzleController

]]></ProtectedString>
						<string name="ScriptGuid">{7A268830-1D3D-4E43-AC79-1B45FF3164D8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">PuzzleController</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a0</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="19">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ShardCollector: Handles shard collection detection and events
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local SoundManager = require(script.Parent.SoundManager)

local ShardCollector = {}
ShardCollector.__index = ShardCollector

local player = Players.LocalPlayer
local character = nil
local humanoid_root_part = nil
local touched_shards = {} -- Track which shards have been touched to prevent duplicate events
local sound_manager = nil -- SoundManager instance
local shard_connections = {} -- Track connections for cleanup: shard -> {touched_connection, proximity_connection}


function ShardCollector.new()
	local self = setmetatable({}, ShardCollector)
	return self
end

function ShardCollector:initialize()
	-- Get SoundManager instance
	sound_manager = _G.SoundManager or SoundManager.new()
	
	-- Wait for character
	if player.Character then
		self:setup_character(player.Character)
	end
	
	player.CharacterAdded:Connect(function(character)
		self:setup_character(character)
	end)
	
	-- Listen for shards
	self:setup_shard_detection()
	
	-- Listen for game reset event
	RemoteEvents.GameReset.OnClientEvent:Connect(function()
		-- Reset touched shards when game is reset
		touched_shards = {}
		
		-- Cleanup old connections
		for shard, connections in pairs(shard_connections) do
			if connections.touched_connection then
				connections.touched_connection:Disconnect()
			end
			if connections.proximity_connection then
				connections.proximity_connection:Disconnect()
			end
		end
		shard_connections = {}
		
		-- Note: setup_shard_detection already listens for Shards folder creation,
		-- so it will automatically reconnect when shards are respawned
	end)
end

function ShardCollector:setup_character(character_instance)
	character = character_instance
	humanoid_root_part = character:WaitForChild("HumanoidRootPart")
	touched_shards = {} -- Reset on respawn
end

function ShardCollector:setup_shard_detection()
	-- Wait for shards folder with retry logic
	local function try_connect_shards()
		local shards_folder = Workspace:FindFirstChild("Shards")
		if shards_folder then
			-- Ensure character is ready before connecting
			if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				self:connect_shards(shards_folder)
			else
				-- Retry after character loads
				spawn(function()
					if player.Character then
						player.Character:WaitForChild("HumanoidRootPart")
					end
					task.wait(0.5) -- Small delay to ensure everything is ready
					if shards_folder.Parent then -- Check if folder still exists
						self:connect_shards(shards_folder)
					end
				end)
			end
		end
	end
	
	-- Try immediately
	try_connect_shards()
	
	-- Also wait with timeout as fallback
	spawn(function()
		local shards_folder = Workspace:WaitForChild("Shards", 15)
		if shards_folder then
			-- Ensure character is ready
			if player.Character then
				player.Character:WaitForChild("HumanoidRootPart", 5)
			end
			task.wait(0.5) -- Small delay
			if shards_folder.Parent then
				self:connect_shards(shards_folder)
			end
		end
	end)
	
	-- Always listen for shards folder creation (handles game reset and late spawning)
	Workspace.ChildAdded:Connect(function(child)
		if child.Name == "Shards" then
			-- Ensure character is ready before connecting
			if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				self:connect_shards(child)
			else
				-- Wait for character if not ready
				spawn(function()
					if player.Character then
						player.Character:WaitForChild("HumanoidRootPart", 5)
					end
					task.wait(0.5)
					if child.Parent then
						self:connect_shards(child)
					end
				end)
			end
		end
	end)
end

function ShardCollector:connect_shards(shards_folder)
	-- Reset touched shards when shards folder is recreated (game reset)
	touched_shards = {}
	
	-- Cleanup old connections for this folder's shards
	for shard, connections in pairs(shard_connections) do
		if not shard.Parent or shard.Parent ~= shards_folder then
			-- Shard no longer exists or belongs to different folder, cleanup
			if connections.touched_connection then
				connections.touched_connection:Disconnect()
			end
			if connections.proximity_connection then
				connections.proximity_connection:Disconnect()
			end
			shard_connections[shard] = nil
		end
	end
	
	-- Connect to existing shards
	for _, shard in ipairs(shards_folder:GetChildren()) do
		if shard:IsA("Part") then
			-- Only connect if not already connected
			if not shard_connections[shard] then
				self:connect_shard(shard)
			end
		else
			warn("[ShardCollector] Found non-Part child:", shard.Name, shard.ClassName)
		end
	end
	
	-- Connect to new shards
	shards_folder.ChildAdded:Connect(function(shard)
		if shard:IsA("Part") then
			-- Only connect if not already connected
			if not shard_connections[shard] then
				self:connect_shard(shard)
			end
		end
	end)
end

function ShardCollector:connect_shard(shard)
	-- Prevent duplicate connections
	if shard_connections[shard] then
		return
	end
	
	-- Ensure character is ready before connecting
	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
		-- Retry when character is ready
		spawn(function()
			if player.Character then
				player.Character:WaitForChild("HumanoidRootPart", 5)
			end
			task.wait(0.1)
			if shard.Parent and not shard_connections[shard] then
				self:connect_shard(shard)
			end
		end)
		return
	end
	
	-- Update humanoid_root_part reference
	if player.Character then
		humanoid_root_part = player.Character:FindFirstChild("HumanoidRootPart")
	end
	
	if not humanoid_root_part then
		return
	end
	
	-- Wait for ShardIndex to be created (handles replication delay after game reset)
	local shard_index_value = shard:WaitForChild("ShardIndex", 2)
	if not shard_index_value then
		warn("[ShardCollector] Shard missing ShardIndex after wait:", shard.Name)
		return
	end
	
	local shard_index = tonumber(shard_index_value.Value)
	if not shard_index then
		warn("[ShardCollector] Invalid shard index value:", shard_index_value.Value)
		return
	end
	
	-- Initialize connections table for this shard
	shard_connections[shard] = {}
	
	-- Use Touched event (primary method)
	local touched_connection = shard.Touched:Connect(function(hit)
		if not humanoid_root_part then
			return
		end
		
		-- Check if the hit part belongs to the player's character
		local hit_parent = hit.Parent
		if not hit_parent then
			return
		end
		
		-- Check if it's the player's character (more flexible check)
		local is_player_character = false
		if hit_parent == player.Character then
			is_player_character = true
		else
			-- Check if hit part is a descendant of player's character
			local player_character = player.Character
			if player_character and hit:IsDescendantOf(player_character) then
				is_player_character = true
			end
		end
		
		if not is_player_character then
			return
		end
		
		-- Prevent duplicate collection
		if touched_shards[shard_index] then
			return
		end
		
		touched_shards[shard_index] = true
		
		-- Play collection sound
		if sound_manager then
			sound_manager:play_sound_2d(136791667101651, {Volume = 0.6})
		end
		
		-- Send collection event to server
		RemoteEvents.CollectShard:FireServer(shard_index)
	end)
	
	-- Store touched connection
	shard_connections[shard].touched_connection = touched_connection
	
	-- Proximity detection as backup (check distance every frame)
	local proximity_connection
	proximity_connection = RunService.Heartbeat:Connect(function()
		-- Update humanoid_root_part reference in case character respawned
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			humanoid_root_part = player.Character:FindFirstChild("HumanoidRootPart")
		end
		
		if not shard.Parent or not humanoid_root_part then
			proximity_connection:Disconnect()
			-- Cleanup connections when shard is destroyed
			if shard_connections[shard] then
				if shard_connections[shard].touched_connection then
					shard_connections[shard].touched_connection:Disconnect()
				end
				shard_connections[shard] = nil
			end
			return
		end
		
		-- Check if already collected
		if touched_shards[shard_index] then
			proximity_connection:Disconnect()
			-- Cleanup connections when shard is collected
			if shard_connections[shard] then
				if shard_connections[shard].touched_connection then
					shard_connections[shard].touched_connection:Disconnect()
				end
				shard_connections[shard] = nil
			end
			return
		end
		
		-- Check distance to player
		local shard_position = shard.Position
		local player_position = humanoid_root_part.Position
		local distance = (shard_position - player_position).Magnitude
		
		local collection_radius = (shard.Size.Magnitude / 2) + 1.5
		
		if distance <= collection_radius then
			touched_shards[shard_index] = true
			proximity_connection:Disconnect()
			
			-- Play collection sound
			if sound_manager then
				sound_manager:play_sound_2d(136791667101651, {Volume = 0.6})
			end
			
			-- Send collection event to server
			RemoteEvents.CollectShard:FireServer(shard_index)
		end
	end)
	
	-- Store proximity connection
	shard_connections[shard].proximity_connection = proximity_connection
end

return ShardCollector]]></ProtectedString>
						<string name="ScriptGuid">{56A8B308-A182-49CE-8346-A27550A6CA4C}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ShardCollector</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a1</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="20">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ShardEffects: Handles visual effects for shards (bobbing and rotation)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local Config = require(ReplicatedStorage.Shared.Config)
local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)

local ShardEffects = {}
ShardEffects.__index = ShardEffects

local shard_connections = {}

function ShardEffects.new()
	local self = setmetatable({}, ShardEffects)
	return self
end

function ShardEffects:start_effects()
	-- Wait for shards folder to be created
	local shards_folder = Workspace:WaitForChild("Shards", 10)
	if shards_folder then
		self:connect_to_shards_folder(shards_folder)
	end
	
	-- Always listen for shards folder creation (handles game reset)
	Workspace.ChildAdded:Connect(function(child)
		if child.Name == "Shards" then
			self:connect_to_shards_folder(child)
		end
	end)
	
	-- Listen for game reset to restart effects
	RemoteEvents.GameReset.OnClientEvent:Connect(function()
		-- Stop all current effects
		self:stop_effects()
		
		-- Wait a bit for new shards to be created, then restart
		spawn(function()
			task.wait(0.5)
			local shards_folder = Workspace:FindFirstChild("Shards")
			if shards_folder then
				self:connect_to_shards_folder(shards_folder)
			end
		end)
	end)
end

function ShardEffects:connect_to_shards_folder(shards_folder)
	-- Connect to all existing shards
	for _, shard in ipairs(shards_folder:GetChildren()) do
		if shard:IsA("Part") then
			self:add_shard_effect(shard)
		end
	end
	
	-- Listen for new shards
	shards_folder.ChildAdded:Connect(function(shard)
		if shard:IsA("Part") then
			self:add_shard_effect(shard)
		end
	end)
end

function ShardEffects:add_shard_effect(shard)
	-- Skip if already has effect
	if shard_connections[shard] then
		return
	end
	
	-- Store base CFrame (position + rotation)
	local base_cframe = shard.CFrame
	local base_position = base_cframe.Position
	local start_time = tick()
	local rotation_angle = 0  -- Track total rotation
	
	-- Create connection for bobbing and rotation
	local connection
	connection = RunService.Heartbeat:Connect(function()
		if not shard.Parent then
			connection:Disconnect()
			shard_connections[shard] = nil
			return
		end
		
		local current_time = tick()
		local elapsed = current_time - start_time
		
		local bob_offset = math.sin(elapsed * Config.SHARD_BOBBING_SPEED) * Config.SHARD_BOBBING_AMPLITUDE
		local new_position = base_position + Vector3.new(0, bob_offset, 0)
		
		rotation_angle = rotation_angle + Config.SHARD_ROTATION_SPEED * (1/60) -- Assume 60 FPS
		
		shard.CFrame = CFrame.new(new_position) * CFrame.Angles(0, math.rad(rotation_angle), 0)
	end)
	
	shard_connections[shard] = connection
end

function ShardEffects:stop_effects()
	for shard, connection in pairs(shard_connections) do
		if connection then
			connection:Disconnect()
		end
	end
	shard_connections = {}
end

return ShardEffects

]]></ProtectedString>
						<string name="ScriptGuid">{7BF9B771-F1F6-45F6-A616-F35A12058EFA}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ShardEffects</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a2</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="21">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- SoundManager: Handles sound effect playback with ID
local SoundService = game:GetService("SoundService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local SoundManager = {}
SoundManager.__index = SoundManager

local player = Players.LocalPlayer
local player_gui = player:WaitForChild("PlayerGui")

-- Sound pool for reusing Sound objects (performance optimization)
local sound_pool = {}
local active_sounds = {} -- Track active sounds for cleanup

-- Default sound properties
local DEFAULT_VOLUME = 0.5
local DEFAULT_PITCH = 1.0
local MAX_POOL_SIZE = 10 -- Maximum number of sounds in pool

function SoundManager.new()
	local self = setmetatable({}, SoundManager)
	return self
end

-- Get a Sound object from pool or create new one
local function get_sound_object()
	local sound = table.remove(sound_pool)
	if not sound then
		sound = Instance.new("Sound")
		sound.Volume = DEFAULT_VOLUME
		sound.Pitch = DEFAULT_PITCH
	end
	return sound
end

-- Return Sound object to pool for reuse
local function return_sound_to_pool(sound)
	if #sound_pool < MAX_POOL_SIZE then
		-- Clean up sound
		sound:Stop()
		sound.SoundId = ""
		sound.Volume = DEFAULT_VOLUME
		sound.Pitch = DEFAULT_PITCH
		sound.Looped = false
		sound.TimePosition = 0
		
		-- Remove from active sounds
		active_sounds[sound] = nil
		
		-- Note: Connections will be automatically cleaned up when sound is reused
		-- No need to manually disconnect them
		
		table.insert(sound_pool, sound)
	else
		-- Pool is full, destroy the sound
		sound:Destroy()
	end
end

-- Play a 2D sound (UI sound, plays from ScreenGui)
function SoundManager:play_sound_2d(sound_id, options)
	options = options or {}
	
	local sound = get_sound_object()
	sound.SoundId = "rbxassetid://" .. tostring(sound_id)
	sound.Volume = options.Volume or DEFAULT_VOLUME
	sound.Pitch = options.Pitch or DEFAULT_PITCH
	sound.Looped = options.Looped or false
	
	-- Parent to a ScreenGui for 2D sound
	local screen_gui = player_gui:FindFirstChild("SoundManagerGui")
	if not screen_gui then
		screen_gui = Instance.new("ScreenGui")
		screen_gui.Name = "SoundManagerGui"
		screen_gui.ResetOnSpawn = false
		screen_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		screen_gui.Parent = player_gui
	end
	
	sound.Parent = screen_gui
	active_sounds[sound] = true
	
	-- Play sound
	sound:Play()
	
	-- Cleanup when sound ends (if not looped)
	if not options.Looped then
		local ended_connection
		ended_connection = sound.Ended:Connect(function()
			ended_connection:Disconnect()
			return_sound_to_pool(sound)
		end)
		
		-- Also handle if sound is stopped manually
		local stopped_connection
		stopped_connection = sound.Stopped:Connect(function()
			stopped_connection:Disconnect()
			if active_sounds[sound] then
				return_sound_to_pool(sound)
			end
		end)
	end
	
	return sound
end

-- Play a 3D sound at a specific position in the world
function SoundManager:play_sound_3d(sound_id, position, options)
	options = options or {}
	
	local sound = get_sound_object()
	sound.SoundId = "rbxassetid://" .. tostring(sound_id)
	sound.Volume = options.Volume or DEFAULT_VOLUME
	sound.Pitch = options.Pitch or DEFAULT_PITCH
	sound.Looped = options.Looped or false
	sound.RollOffMode = options.RollOffMode or Enum.RollOffMode.Inverse
	sound.MaxDistance = options.MaxDistance or 100
	sound.MinDistance = options.MinDistance or 10
	
	-- Create a part to hold the sound at the position
	local sound_part = Instance.new("Part")
	sound_part.Name = "SoundPart"
	sound_part.Size = Vector3.new(1, 1, 1)
	sound_part.Position = position
	sound_part.Anchored = true
	sound_part.CanCollide = false
	sound_part.Transparency = 1
	sound_part.Parent = workspace
	
	sound.Parent = sound_part
	active_sounds[sound] = true
	
	-- Play sound
	sound:Play()
	
	-- Cleanup when sound ends (if not looped)
	if not options.Looped then
		local ended_connection
		ended_connection = sound.Ended:Connect(function()
			ended_connection:Disconnect()
			sound_part:Destroy()
			return_sound_to_pool(sound)
		end)
		
		-- Also handle if sound is stopped manually
		local stopped_connection
		stopped_connection = sound.Stopped:Connect(function()
			stopped_connection:Disconnect()
			if active_sounds[sound] then
				sound_part:Destroy()
				return_sound_to_pool(sound)
			end
		end)
	else
		-- For looped sounds, store the part reference for manual cleanup
		sound:SetAttribute("SoundPart", sound_part)
	end
	
	return sound, sound_part
end

-- Play a sound attached to a specific instance (e.g., a part)
function SoundManager:play_sound_attached(sound_id, parent_instance, options)
	options = options or {}
	
	local sound = get_sound_object()
	sound.SoundId = "rbxassetid://" .. tostring(sound_id)
	sound.Volume = options.Volume or DEFAULT_VOLUME
	sound.Pitch = options.Pitch or DEFAULT_PITCH
	sound.Looped = options.Looped or false
	
	if options.RollOffMode then
		sound.RollOffMode = options.RollOffMode
	end
	if options.MaxDistance then
		sound.MaxDistance = options.MaxDistance
	end
	if options.MinDistance then
		sound.MinDistance = options.MinDistance
	end
	
	sound.Parent = parent_instance
	active_sounds[sound] = true
	
	-- Play sound
	sound:Play()
	
	-- Cleanup when sound ends (if not looped)
	if not options.Looped then
		local ended_connection
		ended_connection = sound.Ended:Connect(function()
			ended_connection:Disconnect()
			return_sound_to_pool(sound)
		end)
		
		-- Also handle if sound is stopped manually
		local stopped_connection
		stopped_connection = sound.Stopped:Connect(function()
			stopped_connection:Disconnect()
			if active_sounds[sound] then
				return_sound_to_pool(sound)
			end
		end)
	end
	
	return sound
end

-- Stop a specific sound
function SoundManager:stop_sound(sound)
	if sound and active_sounds[sound] then
		sound:Stop()
		active_sounds[sound] = nil
		
		-- Cleanup 3D sound part if exists
		local sound_part = sound:GetAttribute("SoundPart")
		if sound_part then
			sound_part:Destroy()
		end
		
		return_sound_to_pool(sound)
	end
end

-- Stop all active sounds
function SoundManager:stop_all_sounds()
	for sound, _ in pairs(active_sounds) do
		sound:Stop()
		active_sounds[sound] = nil
		
		-- Cleanup 3D sound part if exists
		local sound_part = sound:GetAttribute("SoundPart")
		if sound_part then
			sound_part:Destroy()
		end
		
		return_sound_to_pool(sound)
	end
end

-- Set master volume (affects all new sounds)
function SoundManager:set_master_volume(volume)
	DEFAULT_VOLUME = math.clamp(volume, 0, 1)
end

-- Get master volume
function SoundManager:get_master_volume()
	return DEFAULT_VOLUME
end

-- Cleanup all sounds and pool
function SoundManager:cleanup()
	self:stop_all_sounds()
	
	-- Destroy all pooled sounds
	for _, sound in ipairs(sound_pool) do
		sound:Destroy()
	end
	sound_pool = {}
	
	-- Destroy SoundManagerGui if exists
	local screen_gui = player_gui:FindFirstChild("SoundManagerGui")
	if screen_gui then
		screen_gui:Destroy()
	end
end

return SoundManager

]]></ProtectedString>
						<string name="ScriptGuid">{ADCB5509-B8BF-442D-84FB-AE3305A366B1}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">SoundManager</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a3</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXD90733F8CB664920A8A793B9561D5DAF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003a6</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX3792177040664A2391ACB468336C73DD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000034c</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX7B2EACDFF62743A981F485252F37FD0C">
		<Properties>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<Ref name="StudioDefaultStyleSheet">null</Ref>
			<Ref name="StudioInsertWidgetLayerCollectorAutoLinkStyleSheet">null</Ref>
			<token name="VirtualCursorMode">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000034d</UniqueId>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBXC92D8F7B92CC4F779A8218EBFED0E22E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000034f</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX4F7ED2E92891441394A34D49D1C3ED56">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000353</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXB6C788710EDC4130A617B239EE78D927">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000355</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX5E4BCC6556424089BF2561403FAE4B7F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000356</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX1A52A719F56F49BB92282D10F7CAB915">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000359</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBX6A2710EFFDE447D7A672C478574BEF7D">
			<Properties>
				<string name="Value">{C27C0A8A-D399-4F83-93A7-3724E889694D}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000a09</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBXEB0191449E4A4A9C8186FC498C39E08C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000035a</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXB47843BD6D7D414096018E341D689C6A">
		<Properties>
			<int name="MaxItems">1000</int>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000035b</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXE91994C915F7456783256526838536B6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000035c</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBXBE78C3187A4B426385E0611DC255D652">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000035d</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX414B227BA3014C8389BD1C576FFF1378">
		<Properties>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<token name="ControllerModels">1</token>
			<bool name="FadeOutViewOnCollision">true</bool>
			<token name="LaserPointer">1</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000361</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXD98F047F79E94B32BF7B1AB555DB36B2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000362</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXE247213C232247C580C79CEA21419189">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000363</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX128F77FB03CB4CE2AC1DBE9666EC2314">
		<Properties>
			<bool name="AllowInsertFreeAssets">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000364</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXF89C82E5C1EF46789E006701B3F8AEF3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000366</UniqueId>
		</Properties>
	</Item>
	<Item class="AvatarSettings" referent="RBX91107C37C060434D8E6E9C36F4AC669A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AvatarSettings</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000036c</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBXBE55FB8E0FA640CE9901974DEE4AB9BF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LuaWebService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000374</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX8A1270F78BA54804A4BDC33D51B4FE45">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000375</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000376</UniqueId>
		</Properties>
		<Item class="Folder" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Shared</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000392</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="3">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- Configuration constants for the game
local Config = {}

-- Shard configuration
Config.SHARD_COUNT = 20
Config.SHARD_SIZE = Vector3.new(3, 3, 3) -- Increased size for better visibility
Config.SHARD_COLOR = Color3.fromRGB(100, 200, 255)
Config.SHARD_MATERIAL = Enum.Material.Neon
Config.SHARD_BOBBING_SPEED = 2 -- units per second
Config.SHARD_BOBBING_AMPLITUDE = 0.5 -- units
Config.SHARD_ROTATION_SPEED = 90 -- degrees per second

-- Baseplate configuration
Config.BASEPLATE_SIZE = Vector3.new(512, 20, 512)
Config.BASEPLATE_POSITION = Vector3.new(50, -10, 0)

-- Shard spawn positions (20 positions distributed on baseplate)
-- Positions are relative to baseplate center
-- Y = 15 means shards will be 15 units above baseplate center (at y = -10), so at y = 5 (5 units above baseplate top)
-- TEST MODE: Shards spawn in a smaller area near spawn point for quick testing
Config.SHARD_SPAWN_POSITIONS = {
	Vector3.new(-30, 15, -30),
	Vector3.new(-20, 15, -20),
	Vector3.new(-30, 15, 0),
	Vector3.new(-20, 15, 20),
	Vector3.new(-30, 15, 30),
	Vector3.new(-10, 15, -30),
	Vector3.new(-5, 15, -20),
	Vector3.new(-10, 15, 0),
	Vector3.new(-5, 15, 20),
	Vector3.new(-10, 15, 30),
	Vector3.new(0, 15, -30),
	Vector3.new(5, 15, -20),
	Vector3.new(0, 15, 0),
	Vector3.new(5, 15, 20),
	Vector3.new(0, 15, 30),
	Vector3.new(10, 15, -30),
	Vector3.new(20, 15, -20),
	Vector3.new(10, 15, 0),
	Vector3.new(20, 15, 20),
	Vector3.new(30, 15, 30),
}

-- Puzzle configuration
Config.PUZZLE_RING_COUNT = 3
Config.PUZZLE_CENTER_POSITION = Vector3.new(0, 10, 55) -- Center position of puzzle (in front of gate)
Config.PUZZLE_RING_DEPTH_OFFSET = -1 -- Distance between rings along Z axis (depth)
Config.PUZZLE_RING_THICKNESS = 0.5 -- Thickness of each ring
Config.PUZZLE_RING_RADII = {4, 6, 8} -- Radii for outer, middle, inner rings
Config.PUZZLE_RING_1_COLOR = Color3.fromRGB(255, 150, 0) -- Brighter orange
Config.PUZZLE_RING_2_COLOR = Color3.fromRGB(0, 255, 0) -- Green
Config.PUZZLE_RING_3_COLOR = Color3.fromRGB(0, 0, 255) -- Blue
Config.PUZZLE_ROTATION_STEP = 15 -- degrees per interaction
Config.PUZZLE_TARGET_ANGLE = 0 -- Target angle for alignment (0 = upward/forward)
Config.PUZZLE_TOLERANCE = 10 -- degrees tolerance for alignment check
Config.PUZZLE_MARKER_LENGTH = -1 -- Length of marker line on each ring
Config.PUZZLE_MARKER_WIDTH = 0.5 -- Width of marker line
Config.PUZZLE_MARKER_COLOR = Color3.fromRGB(255, 0, 0) -- Yellow marker

-- Gate configuration
-- Gate position: far enough to not overlap with shards (shards are at -30 to +30, gate at +60)
Config.GATE_POSITION = Vector3.new(0, 0, 60)
Config.GATE_SIZE = Vector3.new(30, 40, 5) -- Larger gate for better visibility
Config.GATE_COLOR = Color3.fromRGB(100, 100, 100) -- Darker gray for better contrast

return Config

]]></ProtectedString>
					<string name="ScriptGuid">{FD500CE8-5723-4F5E-B430-7BE4935E7FA3}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Config</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000393</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- RemoteEvents module for client-server communication
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RemoteEvents = {}

-- Get or create RemoteEvents folder
local remote_events_folder = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not remote_events_folder then
	remote_events_folder = Instance.new("Folder")
	remote_events_folder.Name = "RemoteEvents"
	remote_events_folder.Parent = ReplicatedStorage
end

-- Helper function to get or create RemoteEvent
local function get_or_create_event(name)
	local event = remote_events_folder:FindFirstChild(name)
	if not event then
		event = Instance.new("RemoteEvent")
		event.Name = name
		event.Parent = remote_events_folder
	end
	return event
end

-- Shard collection event
local collect_shard_event = get_or_create_event("CollectShard")

-- Shard state update event (server -> client)
local shard_state_event = get_or_create_event("ShardStateUpdate")

-- Puzzle interaction event
local puzzle_interact_event = get_or_create_event("PuzzleInteract")

-- Puzzle state update event (server -> client)
local puzzle_state_event = get_or_create_event("PuzzleStateUpdate")

-- Gate open event (server -> client)
local gate_open_event = get_or_create_event("GateOpen")

-- Timer start event (server -> client)
local timer_start_event = get_or_create_event("TimerStart")

-- Game completion event (server -> client)
local game_complete_event = get_or_create_event("GameComplete")

-- Reset game event (client -> server)
local reset_game_event = get_or_create_event("ResetGame")

-- All shards collected event (server -> client)
local all_shards_collected_event = get_or_create_event("AllShardsCollected")

-- Game reset event (server -> client) - notifies all clients when game is reset
local game_reset_event = get_or_create_event("GameReset")

-- Puzzle solved event (server -> client) - notifies when puzzle is solved (before gate opens)
local puzzle_solved_event = get_or_create_event("PuzzleSolved")

-- Open gate now event (client -> server) - client requests gate to open after countdown
local open_gate_now_event = get_or_create_event("OpenGateNow")

-- Export events
RemoteEvents.CollectShard = collect_shard_event
RemoteEvents.ShardStateUpdate = shard_state_event
RemoteEvents.PuzzleInteract = puzzle_interact_event
RemoteEvents.PuzzleStateUpdate = puzzle_state_event
RemoteEvents.GateOpen = gate_open_event
RemoteEvents.TimerStart = timer_start_event
RemoteEvents.GameComplete = game_complete_event
RemoteEvents.ResetGame = reset_game_event
RemoteEvents.AllShardsCollected = all_shards_collected_event
RemoteEvents.GameReset = game_reset_event
RemoteEvents.PuzzleSolved = puzzle_solved_event
RemoteEvents.OpenGateNow = open_gate_now_event

return RemoteEvents]]></ProtectedString>
					<string name="ScriptGuid">{4F92D981-2A84-48B8-BD41-1741E0AB68F6}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">RemoteEvents</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000394</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ServerScriptService" referent="5">
		<Properties>
			<bool name="LoadStringEnabled">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000377</UniqueId>
		</Properties>
		<Item class="Script" referent="6">
			<Properties>
				<ProtectedString name="Source"><![CDATA[-- Main server initialization
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for Shared folder to be created
local shared_folder = ReplicatedStorage:WaitForChild("Shared", 10)
if not shared_folder then
	warn("Shared folder not found! Make sure Rojo is syncing correctly.")
	return
end

-- Wait for required modules
local config_module = shared_folder:WaitForChild("Config", 10)
local remote_events_module = shared_folder:WaitForChild("RemoteEvents", 10)

if not config_module or not remote_events_module then
	warn("Required modules not found in Shared folder!")
	return
end

local GameManager = require(script.GameManager)

-- Initialize game
local game_manager = GameManager.new()

print("Server initialized successfully!")
]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{EEDC4371-D3EC-456B-8D42-6C9EF6E8ECAB}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Server</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000395</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="7">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- GameManager: Main game logic coordinator
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Wait for Shared folder and modules
local shared_folder = ReplicatedStorage:WaitForChild("Shared", 10)
if not shared_folder then
	error("Shared folder not found in ReplicatedStorage!")
end

local remote_events_module = shared_folder:WaitForChild("RemoteEvents", 10)
local config_module = shared_folder:WaitForChild("Config", 10)

if not remote_events_module or not config_module then
	error("Required modules not found in Shared folder!")
end

local RemoteEvents = require(remote_events_module)
local Config = require(config_module)
local ShardManager = require(script.Parent.ShardManager)
local PuzzleManager = require(script.Parent.PuzzleManager)
local GateManager = require(script.Parent.GateManager)

-- GameManager class implementation
local GameManager = {}
GameManager.__index = GameManager

local shard_manager = nil
local puzzle_manager = nil
local gate_manager = nil
local game_started = false
local timer_started = false
local start_time = 0
local game_completed = false -- Track if game has been completed
local game_reset_in_progress = false -- Track if reset is in progress

function GameManager.new()
	local self = setmetatable({}, GameManager)
	
	shard_manager = ShardManager.new()
	puzzle_manager = PuzzleManager.new()
	gate_manager = GateManager.new()
	
	-- Initialize game
	self:initialize_game()
	
	-- Setup RemoteEvent handlers
	self:setup_handlers()
	
	return self
end

function GameManager:initialize_game()
	
	-- -- Create gate
	gate_manager:create_gate()
	
	-- -- Create puzzle
	puzzle_manager:create_puzzle()
	
	-- Spawn shards
	shard_manager:spawn_shards()
	
	game_started = true
end

function GameManager:setup_handlers()
	-- Handle shard collection
	RemoteEvents.CollectShard.OnServerEvent:Connect(function(player, shard_index)
		if not game_started then
			return
		end
		
		local success = shard_manager:collect_shard(player, shard_index)
		
		if success then
			local count = shard_manager:get_player_count(player)
			
			-- Start timer on first shard collection
			if not timer_started then
				timer_started = true
				start_time = tick()
				RemoteEvents.TimerStart:FireAllClients(start_time)
			end
			
			-- Check if all shards collected
			if shard_manager:get_all_collected() then
				RemoteEvents.AllShardsCollected:FireAllClients()
				-- Show start button when all shards are collected
				puzzle_manager:show_start_button()
			end
		end
	end)
	
	-- Handle puzzle start
	RemoteEvents.PuzzleInteract.OnServerEvent:Connect(function(player, interaction_type, ring_index)
		
		if not game_started then
			warn("[GameManager] Game not started yet!")
			return
		end
		
		if interaction_type == "start" then
			puzzle_manager:start_puzzle()
		elseif interaction_type == "rotate" then
			puzzle_manager:rotate_ring(ring_index)
		else
			warn(string.format("[GameManager] Unknown interaction type: %s", tostring(interaction_type)))
		end
	end)
	
	-- Handle gate opening when puzzle is solved
	RemoteEvents.GateOpen.OnServerEvent:Connect(function()
		-- This shouldn't be called from client, but handle it anyway
	end)
	
	-- Listen for puzzle completion
	spawn(function()
		while true do
			task.wait(0.5)
			if puzzle_manager:is_solved() and not gate_manager:is_open() and not game_completed then
				game_completed = true
				local completion_time = timer_started and (tick() - start_time) or 0
				-- Fire PuzzleSolved event to trigger countdown on client
				RemoteEvents.PuzzleSolved:FireAllClients(completion_time)
			end
		end
	end)
	
	-- Handle gate opening request from client (after countdown)
	RemoteEvents.OpenGateNow.OnServerEvent:Connect(function(player)
		if puzzle_manager:is_solved() and not gate_manager:is_open() then
			gate_manager:open_gate()
			local completion_time = timer_started and (tick() - start_time) or 0
			-- Fire GameComplete after gate opens
			task.wait(0.5) -- Small delay to let gate animation start
			RemoteEvents.GameComplete:FireAllClients(completion_time)
		end
	end)
	
	-- Handle game reset
	RemoteEvents.ResetGame.OnServerEvent:Connect(function(player)
		if not game_started then
			return
		end
		
		-- Only reset if game was completed and not already resetting
		if game_completed and not game_reset_in_progress then
			game_reset_in_progress = true
			self:reset_game()
			-- Notify all clients that game was reset
			RemoteEvents.GameReset:FireAllClients()
			game_reset_in_progress = false
		else
			-- Game already reset or not completed, just acknowledge to this player
			-- They should just close their UI
		end
	end)
end

function GameManager:reset_game()
	-- Reset completion flag
	game_completed = false
	
	-- Reset all managers
	shard_manager:reset()
	puzzle_manager:reset()
	gate_manager:reset()
	
	-- Reset timer
	timer_started = false
	start_time = 0
	
	-- Notify clients to reset timer
	RemoteEvents.TimerStart:FireAllClients(0)
end

return GameManager
]]></ProtectedString>
					<string name="ScriptGuid">{A4951E92-3BA8-43F2-9E8B-EA4BBC9365E5}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">GameManager</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000396</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="8">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- GateManager: Handles gate creation and opening animation
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Config = require(ReplicatedStorage.Shared.Config)

local GateManager = {}
GateManager.__index = GateManager

local gate_model = nil
local gate_open = false

function GateManager.new()
	local self = setmetatable({}, GateManager)
	return self
end

function GateManager:create_gate()
	local gate_folder = Instance.new("Folder")
	gate_folder.Name = "Gate"
	gate_folder.Parent = Workspace
	
	-- Create gate frame (left side) - larger and more visible
	local left_frame = Instance.new("Part")
	left_frame.Name = "LeftFrame"
	left_frame.Size = Vector3.new(6, 40, 6)
	left_frame.Material = Enum.Material.Metal
	left_frame.Color = Config.GATE_COLOR
	left_frame.Anchored = true
	left_frame.Position = Config.GATE_POSITION + Vector3.new(-18, 0, 0)
	left_frame.Parent = gate_folder
	
	-- Create gate frame (right side)
	local right_frame = Instance.new("Part")
	right_frame.Name = "RightFrame"
	right_frame.Size = Vector3.new(6, 40, 6)
	right_frame.Material = Enum.Material.Metal
	right_frame.Color = Config.GATE_COLOR
	right_frame.Anchored = true
	right_frame.Position = Config.GATE_POSITION + Vector3.new(18, 0, 0)
	right_frame.Parent = gate_folder
	
	-- Create gate door (will move when opened) - larger
	local gate_door = Instance.new("Part")
	gate_door.Name = "GateDoor"
	gate_door.Size = Config.GATE_SIZE
	gate_door.Material = Enum.Material.Metal
	gate_door.Color = Color3.fromRGB(80, 80, 80) -- Slightly darker for contrast
	gate_door.Anchored = true
	gate_door.Position = Config.GATE_POSITION
	gate_door.Parent = gate_folder
	
	-- Add top frame for better visibility
	local top_frame = Instance.new("Part")
	top_frame.Name = "TopFrame"
	top_frame.Size = Vector3.new(36, 3, 6)
	top_frame.Material = Enum.Material.Metal
	top_frame.Color = Config.GATE_COLOR
	top_frame.Anchored = true
	top_frame.Position = Config.GATE_POSITION + Vector3.new(0, 21.5, 0)
	top_frame.Parent = gate_folder
	
	gate_model = gate_folder
	gate_open = false
end

function GateManager:open_gate()
	if gate_open then
		return
	end
	
	gate_open = true
	
	if gate_model then
		local gate_door = gate_model:FindFirstChild("GateDoor")
		if gate_door then
			-- Animate gate opening (move up)
			local tween_service = game:GetService("TweenService")
			local tween_info = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			local goal = {Position = gate_door.Position + Vector3.new(0, 35, 0)}
			local tween = tween_service:Create(gate_door, tween_info, goal)
			tween:Play()
		end
	end
end

function GateManager:is_open()
	return gate_open
end

function GateManager:reset()
	gate_open = false
	
	if gate_model then
		local gate_door = gate_model:FindFirstChild("GateDoor")
		if gate_door then
			gate_door.Position = Config.GATE_POSITION
		end
	end
end

return GateManager

]]></ProtectedString>
					<string name="ScriptGuid">{660B577B-9441-4E87-A4DC-4CC4E91B7F7F}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">GateManager</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000397</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="9">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- PuzzleManager: Handles 3-ring puzzle logic
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local Config = require(ReplicatedStorage.Shared.Config)

local PuzzleManager = {}
PuzzleManager.__index = PuzzleManager

local puzzle_rings = {}
local ring_markers = {} -- Store marker parts for each ring
local ring_angles = {0, 0, 0} -- Current angles of each ring
local puzzle_active = false
local puzzle_solved = false
local start_button = nil
local puzzle_folder = nil
local puzzle_created = false
-- ClickDetector removed - rings can only be rotated via UI buttons or keyboard

function PuzzleManager.new()
    local self = setmetatable({}, PuzzleManager)
    return self
end

function PuzzleManager:create_puzzle()
    -- Only create puzzle folder, puzzle elements will be created when all shards are collected
    puzzle_folder = Instance.new("Folder")
    puzzle_folder.Name = "Puzzle"
    puzzle_folder.Parent = Workspace

    puzzle_created = false
end

function PuzzleManager:create_puzzle_elements()
    -- Only create once
    if puzzle_created then
        return
    end

    if not puzzle_folder or not puzzle_folder.Parent then
        warn("[PuzzleManager] Puzzle folder not found! Creating new one...")
        self:create_puzzle()
    end

    -- Create 3 concentric rings stacked along depth axis
    -- Ring 1 = ln nht, xa ngi chi nht
    -- Ring 3 = nh nht, gn ngi chi nht
    for i = 1, Config.PUZZLE_RING_COUNT do
        local radius = Config.PUZZLE_RING_RADII[i]

        -- CHANGED: m bo ring 1 xa nht, ring 3 gn nht (0, offset, 2*offset, ...)
        local depth_offset = (Config.PUZZLE_RING_COUNT - i) * Config.PUZZLE_RING_DEPTH_OFFSET

        local ring_position = Config.PUZZLE_CENTER_POSITION + Vector3.new(0, 0, depth_offset)

        -- Create ring as a torus-like structure using a cylinder
        local ring = Instance.new("Part")
        ring.Name = "Ring" .. i
        ring.Size = Vector3.new(Config.PUZZLE_RING_THICKNESS,  radius * 2, radius * 2)
        ring.Material = Enum.Material.DiamondPlate
        ring.Shape = Enum.PartType.Cylinder
        ring.Anchored = true
        ring.CanCollide = false
        ring.Position = ring_position
        ring.Parent = puzzle_folder


        if i == 1 then
            ring.Color = Config.PUZZLE_RING_1_COLOR
        elseif i == 2 then
            ring.Color = Config.PUZZLE_RING_2_COLOR
        elseif i == 3 then
            ring.Color = Config.PUZZLE_RING_3_COLOR
        end

        -- Create marker line on the ring (visible line/notch)
        local marker = Instance.new("Part")
        marker.Name = "Marker"
        marker.Size = Vector3.new(
            Config.PUZZLE_MARKER_WIDTH,
            Config.PUZZLE_MARKER_WIDTH,
            Config.PUZZLE_MARKER_WIDTH
        )
        marker.Material = Enum.Material.Neon
        marker.Color = Config.PUZZLE_MARKER_COLOR
        marker.Anchored = true
        marker.CanCollide = false
        marker.Parent = ring

        -- Position marker at the top of the ring (angle 0 = upward)
        local marker_offset = radius + (Config.PUZZLE_MARKER_LENGTH / 2)
        marker.Position = ring_position + Vector3.new(0, marker_offset, 0)
        marker.Rotation = Vector3.new(0, 0, 90)

        -- Store marker reference
        ring_markers[i] = marker

        -- Add number label on ring
        local billboard_gui = Instance.new("BillboardGui")
        billboard_gui.Size = UDim2.new(0, 80, 0, 80)
        billboard_gui.StudsOffset = Vector3.new(0, radius + 2, 0)
        billboard_gui.AlwaysOnTop = true
        billboard_gui.Parent = ring

        -- local number_label = Instance.new("TextLabel")
        -- number_label.Size = UDim2.new(1, 0, 1, 0)
        -- number_label.BackgroundTransparency = 0.5
        -- number_label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        -- number_label.Text = "Ring " .. i
        -- number_label.TextColor3 = Color3.fromRGB(255, 255, 255)
        -- number_label.TextScaled = true
        -- number_label.Font = Enum.Font.GothamBold
        -- number_label.Parent = billboard_gui

        -- Add interaction part (invisible button covering the ring area)
        local interaction = Instance.new("Part")
        interaction.Name = "Interaction"
        interaction.Size = Vector3.new(
            radius * 2 + 2,
            radius * 2 + 2,
            Config.PUZZLE_RING_THICKNESS + 1
        )
        interaction.Transparency = 1
        interaction.CanCollide = false
        interaction.CanTouch = false
        interaction.Anchored = true
        interaction.Position = ring_position
        interaction.Parent = ring

        -- ClickDetector removed - rings can only be rotated via UI buttons or keyboard

        -- Add StringValue to identify ring index
        local string_value = Instance.new("StringValue")
        string_value.Name = "RingIndex"
        string_value.Value = tostring(i)
        string_value.Parent = interaction

        puzzle_rings[i] = ring
        ring_angles[i] = math.random(0, 359) -- Random initial angle for each ring
    end

    -- Update initial visual rotation
    self:update_ring_rotations()

    -- Create start button - larger and more visible
    start_button = Instance.new("Part")
    start_button.Name = "StartButton"
    start_button.Size = Vector3.new(10, 4, 10)
    start_button.Rotation = Vector3.new(0, 90, 0)
    start_button.Material = Enum.Material.Neon
    start_button.Color = Color3.fromRGB(0, 255, 0)
    start_button.Anchored = true
    start_button.CanCollide = false
    start_button.CanTouch = true
    start_button.Transparency = 0
    start_button.Position = Config.GATE_POSITION + Vector3.new(0, 2, -15) -- In front of gate, at eye level
    start_button.Parent = puzzle_folder

    local point_light = Instance.new("PointLight")
    point_light.Color = Color3.fromRGB(0, 255, 0)
    point_light.Brightness = 2
    point_light.Range = 20
    point_light.Parent = start_button

    local surface_gui = Instance.new("SurfaceGui")
    surface_gui.Face = Enum.NormalId.Top
    surface_gui.Parent = start_button

    local text_label = Instance.new("TextLabel")
    text_label.Size = UDim2.new(1, 0, 1, 0)
    text_label.BackgroundTransparency = 0.3
    text_label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    text_label.Text = "START PUZZLE"
    text_label.TextColor3 = Color3.fromRGB(255, 255, 255)
    text_label.TextScaled = true
    text_label.Font = Enum.Font.GothamBold
    text_label.Parent = surface_gui

    -- OPTIONAL: start button t bt puzzle trn server khi chm
    start_button.Touched:Connect(function(hit)
        local character = hit.Parent
        local player = game.Players:GetPlayerFromCharacter(character)
        if player then
            self:start_puzzle() -- This will hide the button automatically
        end
    end)

    -- Pulsing animation
    spawn(function()
        local button_ref = start_button -- Store reference
        while button_ref and button_ref.Parent do
            -- Check again before creating tween
            if not button_ref or not button_ref.Parent then
                break
            end
            
            local success1, tween1 = pcall(function()
                return TweenService:Create(
                    button_ref,
                    TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
                    { Transparency = 0.3 }
                )
            end)
            
            if success1 and tween1 then
                tween1:Play()
                tween1.Completed:Wait()
            else
                break -- Button was destroyed
            end

            -- Check again before second tween
            if not button_ref or not button_ref.Parent then
                break
            end

            local success2, tween2 = pcall(function()
                return TweenService:Create(
                    button_ref,
                    TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
                    { Transparency = 0 }
                )
            end)
            
            if success2 and tween2 then
                tween2:Play()
                tween2.Completed:Wait()
            else
                break -- Button was destroyed
            end
        end
    end)

    -- Animate appearance of puzzle elements
    start_button.Size = Vector3.new(5, 2, 5)
    local button_tween = TweenService:Create(
        start_button,
        TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
        { Size = Vector3.new(10, 4, 10) }
    )
    button_tween:Play()

    for i = 1, Config.PUZZLE_RING_COUNT do
        if puzzle_rings[i] then
            local original_size = puzzle_rings[i].Size
            puzzle_rings[i].Size = original_size * 0.5
            local ring_tween = TweenService:Create(
                puzzle_rings[i],
                TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
                { Size = original_size }
            )
            ring_tween:Play()
        end
    end

    puzzle_created = true
end

function PuzzleManager:start_puzzle()
    if not puzzle_created then
        warn("[PuzzleManager] Puzzle elements not created yet!")
        return false
    end

    if puzzle_active or puzzle_solved then
        return false
    end

    puzzle_active = true
    -- Keep random initial angles

    self:update_ring_rotations()
    
    -- Hide start button when puzzle starts
    self:hide_start_button()
    
    -- Enable ring interactions
    for i = 1, Config.PUZZLE_RING_COUNT do
        if puzzle_rings[i] then
            local interaction = puzzle_rings[i]:FindFirstChild("Interaction")
            if interaction then
                interaction.CanTouch = true
            end
            -- ClickDetector removed - rings can only be rotated via UI buttons or keyboard
        end
    end
    
    RemoteEvents.PuzzleStateUpdate:FireAllClients(true, ring_angles)
    return true
end

function PuzzleManager:update_ring_rotations()
    -- Update visual rotation of rings and markers
    for i = 1, Config.PUZZLE_RING_COUNT do
        if puzzle_rings[i] then
            local angle = ring_angles[i]
            puzzle_rings[i].Rotation = Vector3.new(90, angle, 90)

            if ring_markers[i] then
                local radius = Config.PUZZLE_RING_RADII[i]
                local depth_offset = (Config.PUZZLE_RING_COUNT - i) * Config.PUZZLE_RING_DEPTH_OFFSET
                local ring_position = Config.PUZZLE_CENTER_POSITION + Vector3.new(0, 0, depth_offset)

                local rad = math.rad(angle)
                local marker_offset = radius + (Config.PUZZLE_MARKER_LENGTH / 2)
                local marker_x = math.sin(rad) * marker_offset
                local marker_y = math.cos(rad) * marker_offset

                ring_markers[i].Position = ring_position + Vector3.new(marker_x, marker_y, -0.25)
                ring_markers[i].Rotation = Vector3.new(0, -angle, 0)
            end
        end
    end
end

function PuzzleManager:rotate_ring(ring_index)
    if not puzzle_created then
        warn("[PuzzleManager] Puzzle elements not created yet!")
        return false
    end

    if puzzle_solved then
        -- Puzzle already solved, silently ignore (no need to warn)
        return false
    end

    if not puzzle_active then
        -- Puzzle not active yet or already solved, silently ignore
        return false
    end

    if ring_index < 1 or ring_index > Config.PUZZLE_RING_COUNT then
        warn(string.format("[PuzzleManager] Invalid ring index: %d", ring_index))
        return false
    end

    -- Rotate ring by fixed step
    ring_angles[ring_index] =
        (ring_angles[ring_index] + Config.PUZZLE_ROTATION_STEP) % 360

    self:update_ring_rotations()

    local solved = self:check_solution()

    RemoteEvents.PuzzleStateUpdate:FireAllClients(puzzle_active, ring_angles)

    if solved then
        self:solve_puzzle()
    end

    return true
end

function PuzzleManager:check_solution()
    -- CHANGED: check alignment tng i gia cc ring
    -- Ly ring 1 lm chun, cc ring cn li ch cn lch trong tolerance
    local reference_angle = ring_angles[1]

    for i = 2, Config.PUZZLE_RING_COUNT do
        local current_angle = ring_angles[i]

        local diff = (current_angle - reference_angle + 180) % 360 - 180
        local abs_diff = math.abs(diff)

        if abs_diff > Config.PUZZLE_TOLERANCE then
            return false
        end
    end

    -- Tt c marker trng nhau (hoc gn trng nhau)
    return true
end

function PuzzleManager:solve_puzzle()
    if puzzle_solved then
        return
    end

    puzzle_solved = true
    puzzle_active = false


    -- Notify that puzzle is solved (GameManager will handle gate opening)
    RemoteEvents.GateOpen:FireAllClients()
end

function PuzzleManager:is_solved()
    return puzzle_solved
end

function PuzzleManager:show_start_button()
    self:create_puzzle_elements()
end

function PuzzleManager:hide_start_button()
    if start_button and start_button.Parent then
        -- Hide button with animation
        local tween_service = game:GetService("TweenService")
        local hide_tween = tween_service:Create(
            start_button,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
            { Transparency = 1, Size = Vector3.new(0, 0, 0) }
        )
        hide_tween:Play()
        hide_tween.Completed:Connect(function()
            -- Disable interaction after animation
            start_button.CanTouch = false
        end)
    end
end

function PuzzleManager:destroy_puzzle_elements()
    for i = 1, Config.PUZZLE_RING_COUNT do
        if puzzle_rings[i] and puzzle_rings[i].Parent then
            puzzle_rings[i]:Destroy()
        end
        puzzle_rings[i] = nil
        ring_markers[i] = nil
-- ClickDetector references removed
    end

    if start_button and start_button.Parent then
        start_button:Destroy()
    end
    start_button = nil

    puzzle_created = false
    ring_angles = {0, 0, 0}
end

function PuzzleManager:reset()
    puzzle_active = false
    puzzle_solved = false
    ring_angles = {0, 0, 0}

    -- Disable ring interactions before destroying
    for i = 1, Config.PUZZLE_RING_COUNT do
        if puzzle_rings[i] then
            local interaction = puzzle_rings[i]:FindFirstChild("Interaction")
            if interaction then
                interaction.CanTouch = false
            end
            -- ClickDetector removed - rings can only be rotated via UI buttons or keyboard
        end
    end

    self:destroy_puzzle_elements()
    RemoteEvents.PuzzleStateUpdate:FireAllClients(false, ring_angles)
end

return PuzzleManager
]]></ProtectedString>
					<string name="ScriptGuid">{52C3CD5F-8628-4ADF-83C8-8745EAC18DBE}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">PuzzleManager</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000398</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="10">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- ShardManager: Handles shard spawning, collection, and state management
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local RemoteEvents = require(ReplicatedStorage.Shared.RemoteEvents)
local Config = require(ReplicatedStorage.Shared.Config)

local ShardManager = {}
ShardManager.__index = ShardManager

-- Track collected shards per player
local player_shard_counts = {}
local shard_states = {} -- Track which shards are collected (by index)
local shards = {} -- Store shard instances
local shard_base_positions = {} -- Store base positions (before bobbing) for accurate distance checking

function ShardManager.new()
	local self = setmetatable({}, ShardManager)

	-- Initialize shard states (all uncollected)
	for i = 1, Config.SHARD_COUNT do
		shard_states[i] = false
	end
	
	-- Initialize player counts
	for _, player in ipairs(game.Players:GetPlayers()) do
		player_shard_counts[player] = 0
	end
	
	-- Listen for new players
	game.Players.PlayerAdded:Connect(function(player)
		player_shard_counts[player] = 0
		-- Send current shard states to new player
		task.wait(0.5) -- Wait for client to load
		RemoteEvents.ShardStateUpdate:FireClient(player, shard_states, player_shard_counts[player])
	end)
	
	game.Players.PlayerRemoving:Connect(function(player)
		player_shard_counts[player] = nil
	end)
	
	return self
end

function ShardManager:spawn_shards()
	local baseplate = Workspace:FindFirstChild("Baseplate")
	if not baseplate then
		warn("[ShardManager] Baseplate not found!")
		return
	end
	
	
	local shards_folder = Instance.new("Folder")
	shards_folder.Name = "Shards"
	shards_folder.Parent = Workspace
	
    -- Spawn shards
	for i = 1, Config.SHARD_COUNT do
		local shard = Instance.new("Part")
		shard.Name = "Shard" .. i
		shard.Size = Config.SHARD_SIZE
		shard.Material = Config.SHARD_MATERIAL
		shard.Color = Config.SHARD_COLOR
		shard.Shape = Enum.PartType.Block
		shard.Anchored = true
		shard.CanCollide = false
		shard.CanTouch = true -- Enable touch detection
		local base_position = Config.BASEPLATE_POSITION + Config.SHARD_SPAWN_POSITIONS[i]
		shard.Position = base_position
		
		-- Add ShardIndex BEFORE parenting to folder (ensures it replicates together)
		local string_value = Instance.new("StringValue")
		string_value.Name = "ShardIndex"
		string_value.Value = tostring(i)
		string_value.Parent = shard
		
		-- Now parent to folder (ShardIndex will replicate with shard)
		shard.Parent = shards_folder
		
		-- Store base position for accurate distance checking (ignoring bobbing effects)
		shard_base_positions[i] = base_position
		
		shards[i] = shard
	end
end

function ShardManager:collect_shard(player, shard_index)
	-- Validate shard index
	if not shard_index then
		warn(string.format("[ShardManager] Shard index is nil!"))
		return false
	end
	
	if type(shard_index) == "string" then
		shard_index = tonumber(shard_index)
	end
	
	if not shard_index or shard_index < 1 or shard_index > Config.SHARD_COUNT then
		warn(string.format("[ShardManager] Invalid shard index: %s (range: 1-%d)", tostring(shard_index), Config.SHARD_COUNT))
		return false
	end
	
	-- Check if already collected
	if shard_states[shard_index] then
		return false
	end
	
	-- Validate player has touched the shard (basic anti-cheat)
	local shard = shards[shard_index]
	if not shard then
		warn(string.format("[ShardManager] Shard %d not found in shards table!", shard_index))
		return false
	end
	
	if not shard.Parent then
		warn(string.format("[ShardManager] Shard %d has no parent (already destroyed?)", shard_index))
		return false
	end
	
	-- Check distance (anti-cheat: player must be near shard)
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return false
	end
	
	local player_position = character.HumanoidRootPart.Position
	-- Use base position instead of current position to account for bobbing effects
	local shard_base_position = shard_base_positions[shard_index]
	local shard_current_position = shard.Position
	
	-- Check distance to both base and current position (whichever is closer)
	local distance_to_base = (player_position - shard_base_position).Magnitude
	local distance_to_current = (player_position - shard_current_position).Magnitude
	local distance = math.min(distance_to_base, distance_to_current)
	
	-- Increased max collection distance to account for bobbing effects, client-side proximity detection, and network latency
	-- Client uses collection_radius ~9 units, but network latency and position sync can cause larger distances
	-- Using 50 units to be safe while still preventing obvious cheating
	local max_collection_distance = 50
	
	if distance > max_collection_distance then
		warn(string.format("[ShardManager] Player %s tried to collect shard %d from too far away (distance to base: %.2f, to current: %.2f, min: %.2f, max: %.2f)", 
			player.Name, shard_index, distance_to_base, distance_to_current, distance, max_collection_distance))
		return false
	end
	
	-- Mark as collected
	shard_states[shard_index] = true
	
	-- Update player count
	if not player_shard_counts[player] then
		player_shard_counts[player] = 0
	end
	player_shard_counts[player] = player_shard_counts[player] + 1
	
	-- Remove shard from workspace
	shard:Destroy()
	
	-- Notify all clients with individual player counts
	for target_player, count in pairs(player_shard_counts) do
		if target_player and target_player.Parent then
			RemoteEvents.ShardStateUpdate:FireClient(target_player, shard_states, count)
		end
	end
	
	return true
end

function ShardManager:get_player_count(player)
	return player_shard_counts[player] or 0
end

function ShardManager:get_all_collected()
	local all_collected = true
	for i = 1, Config.SHARD_COUNT do
		if not shard_states[i] then
			all_collected = false
			break
		end
	end
	return all_collected
end

function ShardManager:reset()
	-- Reset all shard states
	for i = 1, Config.SHARD_COUNT do
		shard_states[i] = false
	end
	
	-- Reset player counts
	for player, _ in pairs(player_shard_counts) do
		player_shard_counts[player] = 0
	end
	
	-- Remove old shards
	local shards_folder = Workspace:FindFirstChild("Shards")
	if shards_folder then
		shards_folder:Destroy()
	end
	
	-- Clear shards table and base positions
	shards = {}
	shard_base_positions = {}
	
	-- Respawn shards
	self:spawn_shards()
	
	-- Notify all clients with individual player counts
	for target_player, count in pairs(player_shard_counts) do
		if target_player and target_player.Parent then
			RemoteEvents.ShardStateUpdate:FireClient(target_player, shard_states, count or 0)
		end
	end
end

return ShardManager]]></ProtectedString>
					<string name="ScriptGuid">{6E290BC8-C875-4795-86D4-F4D9FE30564E}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">ShardManager</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000399</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBXF3A89A71B3CD45B985CEEA68EBBE4015">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000378</UniqueId>
		</Properties>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBX476D17C75E984E2D85C8EE6619D9CA35">
		<Properties>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000037e</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX388754296E8D46D6AF06ADE6ECD91121">
		<Properties>
			<bool name="HttpEnabled">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da0000038f</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="0">
		<Properties>
			<Color3 name="Ambient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="Brightness">2</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<token name="ExtendLightRangeTo120">0</token>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<token name="LightingStyle">1</token>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<bool name="PrioritizeLightingQuality">false</bool>
			<float name="ShadowSoftness">0.5</float>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
			<BinaryString name="AttributesSerialize"><![CDATA[AgAAACYAAABSQlhfTGlnaHRpbmdUZWNobm9sb2d5VW5pZmllZE1pZ3JhdGlvbgMBIAAAAFJC
WF9PcmlnaW5hbFRlY2hub2xvZ3lPbkZpbGVMb2FkBAEAAAA=]]></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Lighting</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da00000391</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX30711E8C57AC439091986F971D064423">
		<Properties>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<bool name="ThrottlePhysicsToRealtime">true</bool>
			<double name="Timeout">10</double>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TestService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000003d6</UniqueId>
		</Properties>
	</Item>
	<Item class="SerializationService" referent="RBXC5B80523C3F64E6D9CCC2B1F78901D87">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">SerializationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000005df</UniqueId>
		</Properties>
	</Item>
	<Item class="VideoService" referent="RBXAD593D59172F4805A2E0CB056486B598">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000005e4</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBXAC5FF7DD546740F9B865844E28437B0F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LodDataService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000005e5</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX0BFA3A6814E24C3D9D3E281BCB309EC2">
		<Properties>
			<bool name="Enabled">true</bool>
			<int name="MaxIndicatorsVisible">16</int>
			<int name="MaxPromptsVisible">16</int>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">75e03f12eb36b72e0921f9da000006b3</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>